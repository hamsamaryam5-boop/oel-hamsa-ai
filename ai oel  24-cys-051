import heapq
import random
import time

# Grid size
ROWS, COLS = 10, 10
START = (0, 0)
GOAL = (9, 9)

# Heuristic (Manhattan Distance)
def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

# Generate random maze
def generate_maze():
    maze = [[0 for _ in range(COLS)] for _ in range(ROWS)]
    for i in range(ROWS):
        for j in range(COLS):
            if random.random() < 0.2:
                maze[i][j] = 1  # wall
    maze[START[0]][START[1]] = 0
    maze[GOAL[0]][GOAL[1]] = 0
    return maze

# A* Algorithm
def astar(maze, start, goal):
    pq = []
    heapq.heappush(pq, (0, start))
    came_from = {}
    g_score = {start: 0}

    while pq:
        _, current = heapq.heappop(pq)

        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            return path[::-1]

        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
            nx, ny = current[0]+dx, current[1]+dy
            neighbor = (nx, ny)

            if 0 <= nx < ROWS and 0 <= ny < COLS and maze[nx][ny] == 0:
                tentative_g = g_score[current] + 1
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    g_score[neighbor] = tentative_g
                    f = tentative_g + heuristic(neighbor, goal)
                    heapq.heappush(pq, (f, neighbor))
                    came_from[neighbor] = current
    return None

# Introduce dynamic changes
def update_maze(maze):
    for _ in range(5):
        x, y = random.randint(0, 9), random.randint(0, 9)
        if (x, y) not in [START, GOAL]:
            maze[x][y] = 1 if maze[x][y] == 0 else 0

# Run one scenario
def run_scenario():
    maze = generate_maze()
    current = START
    path_length = 0
    replanning_time = 0
    success = True

    while current != GOAL:
        start_time = time.time()
        path = astar(maze, current, GOAL)
        replanning_time += time.time() - start_time

        if not path:
            success = False
            break

        for step in path:
            if maze[step[0]][step[1]] == 1:
                break
            current = step
            path_length += 1

            if random.random() < 0.3:
                update_maze(maze)

            if current == GOAL:
                break

    return success, path_length, replanning_time

# Run 50 scenarios
success_count = 0
results = []

for i in range(1, 51):
    success, length, time_taken = run_scenario()
    results.append((i, success, length, round(time_taken, 4)))
    if success:
        success_count += 1

# Display Results
print("Scenario | Success | Path Length | Replanning Time (s)")
print("-"*50)
for r in results:
    print(r)

print("\nOverall Success Rate:", (success_count / 50) * 100, "%")




output:
Scenario | Success | Path Length | Replanning Time (s)
--------------------------------------------------
(1, True, 18, 0.0001)
(2, True, 18, 0.0003)
(3, True, 28, 0.0004)
(4, False, 15, 0.0003)
(5, True, 20, 0.0002)
(6, False, 11, 0.0003)
(7, False, 10, 0.0003)
(8, False, 0, 0.0)
(9, True, 18, 0.0002)
(10, True, 20, 0.0002)
(11, False, 16, 0.0003)
(12, True, 20, 0.0003)
(13, False, 11, 0.0003)
(14, False, 14, 0.0005)
(15, False, 0, 0.0003)
(16, False, 0, 0.0)
(17, False, 14, 0.0006)
(18, True, 18, 0.0003)
(19, True, 22, 0.0005)
(20, True, 40, 0.0006)
(21, True, 28, 0.0004)
(22, True, 20, 0.0002)
(23, False, 0, 0.0002)
...
(49, False, 13, 0.0006)
(50, True, 20, 0.0003)

Overall Success Rate: 60.0 %



task2:

class CyberExpertSystem:
    def __init__(self):
        self.facts = {}
        self.trace = []
    def ask_user(self, question):
        answer = input(question + " (yes/no): ").strip().lower()
        return answer == "yes"
    def get_facts(self):
        self.facts["high_traffic"] = self.ask_user("Is there unusually high network traffic?")
        self.facts["no_user_activity"] = self.ask_user("Is there no legitimate user activity?")
        self.facts["multiple_ports"] = self.ask_user("Are multiple ports being accessed rapidly?")
        self.facts["unknown_exe"] = self.ask_user("Is an unknown executable detected?")
    def infer(self):
        if self.facts["high_traffic"] and self.facts["no_user_activity"]:
            self.trace.append("Rule fired: IF high traffic AND no user activity THEN DDoS")
            return "DDoS Attack"
if self.facts["multiple_ports"] and self.facts["no_user_activity"]:
            self.trace.append("Rule fired: IF multiple ports accessed AND no user activity THEN Port Scan")
            return "Port Scanning"
                    if self.facts["unknown_exe"]:
            self.trace.append("Rule fired: IF unknown executable detected THEN Malware")
            return "Malware Infection"

        self.trace.append("No threat rules matched â†’ Normal Traffic")
        return "Normal Traffic"
    def diagnose(self):
        self.get_facts()
        threat = self.infer()
        return threat
        def test_scenarios():
    scenarios = [
        {"high_traffic": True, "no_user_activity": True, "multiple_ports": False, "unknown_exe": False, "expected": "DDoS Attack"},
        {"high_traffic": False, "no_user_activity": True, "multiple_ports": True, "unknown_exe": False, "expected": "Port Scanning"},
        {"high_traffic": False, "no_user_activity": False, "multiple_ports": False, "unknown_exe": True, "expected": "Malware Infection"},
        {"high_traffic": False, "no_user_activity": False, "multiple_ports": False, "unknown_exe": False, "expected": "Normal Traffic"},
        {"high_traffic": True, "no_user_activity": True, "multiple_ports": True, "unknown_exe": False, "expected": "DDoS Attack"},
        {"high_traffic": False, "no_user_activity": False, "multiple_ports": False, "unknown_exe": True, "expected": "Malware Infection"},
        {"high_traffic": False, "no_user_activity": True, "multiple_ports": True, "unknown_exe": False, "expected": "Port Scanning"},
        {"high_traffic": False, "no_user_activity": False, "multiple_ports": False, "unknown_exe": False, "expected": "Normal Traffic"},
        {"high_traffic": True, "no_user_activity": True, "multiple_ports": False, "unknown_exe": False, "expected": "DDoS Attack"},
        {"high_traffic": False, "no_user_activity": False, "multiple_ports": False, "unknown_exe": True, "expected": "Malware Infection"}
    ]
correct_count = 0
    for i, s in enumerate(scenarios, 1):
        system = CyberExpertSystem()
        system.facts = {
            "high_traffic": s["high_traffic"],
            "no_user_activity": s["no_user_activity"],
            "multiple_ports": s["multiple_ports"],
            "unknown_exe": s["unknown_exe"]
        }
        result = system.infer()
        print(f"Scenario {i}: Expected = {s['expected']}, Diagnosed = {result}")
        print("Reasoning Trace:", system.trace)
        print("-" * 50)
        if result == s["expected"]:
            correct_count += 1
    accuracy = (correct_count / len(scenarios)) * 100
    print(f"Accuracy on 10 test scenarios: {accuracy}%"
def main():
    print("Cybersecurity Threat Diagnosis Expert System")
    print("Do you want to run test scenarios automatically? (yes/no)")
    choice = input().strip().lower()
    if choice == "yes":
        test_scenarios()
    else:
        system = CyberExpertSystem()
        threat = system.diagnose()
        print("\nDiagnosis Result:", threat)
        print("Reasoning Trace:", system.trace)
if __name__ == "__main__":
    main()







task3:
import math
import random

PLAYER = "X"      # Memory-limited agent
OPPONENT = "O"    # Basic minimax
EMPTY = " "

WIN_COMBOS = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
]

# ---------------------------
# Utility functions
# ---------------------------
def check_winner(board):
    for combo in WIN_COMBOS:
        if board[combo[0]] == board[combo[1]] == board[combo[2]] != EMPTY:
            return board[combo[0]]
    if EMPTY not in board:
        return "Draw"
    return None


# ---------------------------
# Basic Minimax (Opponent)
# ---------------------------
def basic_minimax(board, is_max):
    result = check_winner(board)
    if result == PLAYER:
        return 1
    if result == OPPONENT:
        return -1
    if result == "Draw":
        return 0

    if is_max:
        best = -math.inf
        for i in range(9):
            if board[i] == EMPTY:
                board[i] = PLAYER
                best = max(best, basic_minimax(board, False))
                board[i] = EMPTY
        return best
    else:
        best = math.inf
        for i in range(9):
            if board[i] == EMPTY:
                board[i] = OPPONENT
                best = min(best, basic_minimax(board, True))
                board[i] = EMPTY
        return best


def basic_best_move(board):
    best_val = math.inf
    move = -1
    for i in range(9):
        if board[i] == EMPTY:
            board[i] = OPPONENT
            val = basic_minimax(board, True)
            board[i] = EMPTY
            if val < best_val:
                best_val = val
                move = i
    return move


# ---------------------------
# Memory-Limited Minimax Agent
# ---------------------------
class LimitedMemoryAgent:
    def __init__(self, memory_limit):
        self.memory_limit = memory_limit
        self.memory_used = 0

    def minimax(self, board, depth, alpha, beta, is_max):
        self.memory_used += 1
        if self.memory_used >= self.memory_limit:
            return 0

        result = check_winner(board)
        if result == PLAYER:
            return 1
        if result == OPPONENT:
            return -1
        if result == "Draw" or depth == 0:
            return 0

        if is_max:
            best = -math.inf
            for i in range(9):
                if board[i] == EMPTY:
                    board[i] = PLAYER
                    best = max(best, self.minimax(board, depth-1, alpha, beta, False))
                    board[i] = EMPTY
                    alpha = max(alpha, best)
                    if beta <= alpha:
                        break
            return best
        else:
            best = math.inf
            for i in range(9):
                if board[i] == EMPTY:
                    board[i] = OPPONENT
                    best = min(best, self.minimax(board, depth-1, alpha, beta, True))
                    board[i] = EMPTY
                    beta = min(beta, best)
                    if beta <= alpha:
                        break
            return best

    def best_move(self, board, depth):
        self.memory_used = 0
        best_val = -math.inf
        move = -1

        for i in range(9):
            if board[i] == EMPTY:
                board[i] = PLAYER
                val = self.minimax(board, depth, -math.inf, math.inf, False)
                board[i] = EMPTY
                if val > best_val:
                    best_val = val
                    move = i
        return move


# ---------------------------
# Play Games & Measure Performance
# ---------------------------
def play_games(memory_limit, depth, games=20):
    agent = LimitedMemoryAgent(memory_limit)
    wins = losses = draws = 0

    for _ in range(games):
        board = [EMPTY] * 9
        turn = PLAYER

        while True:
            if turn == PLAYER:
                move = agent.best_move(board, depth)
            else:
                move = basic_best_move(board)

            board[move] = turn
            result = check_winner(board)

            if result:
                if result == PLAYER:
                    wins += 1
                elif result == OPPONENT:
                    losses += 1
                else:
                    draws += 1
                break

            turn = OPPONENT if turn == PLAYER else PLAYER

    return wins, losses, draws


# ---------------------------
# MAIN EXPERIMENT
# ---------------------------
print("\nMEMORY-LIMITED MINIMAX EXPERIMENT\n")

settings = [
    (50, 2),
    (100, 3),
    (200, 4)
]

for mem, depth in settings:
    w, l, d = play_games(mem, depth)
    print(f"Memory Limit: {mem}")
    print(f"Search Depth: {depth}")
    print(f"Wins: {w}, Losses: {l}, Draws: {d}")
    print(f"Win Rate: {w/20*100:.1f}%")
    print("-" * 40)




output:

MEMORY-LIMITED MINIMAX EXPERIMENT

Memory Limit: 50
Search Depth: 2
Wins: 0, Losses: 0, Draws: 20
Win Rate: 0.0%
----------------------------------------
Memory Limit: 100
Search Depth: 3
Wins: 0, Losses: 0, Draws: 20
Win Rate: 0.0%
----------------------------------------
Memory Limit: 200
Search Depth: 4
Wins: 0, Losses: 0, Draws: 20
Win Rate: 0.0%




task4:
import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.neural_network import MLPClassifier

# -----------------------------------
# EMBEDDED DATASET (ONLINE COMPILER)
# -----------------------------------
data = {
    "studytime": [2,3,1,4,2,3,1,4,2,3,4,1,2,3,4],
    "absences": [4,2,10,0,6,3,12,1,5,2,0,14,3,4,1],
    "failures": [0,0,2,0,1,0,3,0,1,0,0,2,1,0,0],
    "internet": [1,1,0,1,0,1,0,1,0,1,1,0,1,1,1],
    "G1": [12,14,8,16,10,15,7,17,11,13,18,6,12,14,16],
    "G2": [13,15,9,17,11,14,8,18,12,14,17,7,13,15,17],
    "G3": ["Medium","High","Low","High","Medium",
           "High","Low","High","Medium","Medium",
           "High","Low","Medium","High","High"]
}

df = pd.DataFrame(data)

# -----------------------------------
# Encode Target
# -----------------------------------
df["G3"] = df["G3"].map({"Low":0, "Medium":1, "High":2})

# -----------------------------------
# Split Data
# -----------------------------------
X = df.drop("G3", axis=1)
y = df["G3"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42)

# -----------------------------------
# Scaling
# -----------------------------------
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# -----------------------------------
# Models
# -----------------------------------
models = {
    "Random Forest": RandomForestClassifier(),
    "Decision Tree": DecisionTreeClassifier(),
    "SVM": SVC(),
    "Naive Bayes": GaussianNB(),
    "MLP": MLPClassifier(max_iter=500)
}

results = {}

for name, model in models.items():
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    results[name] = accuracy_score(y_test, pred)

# -----------------------------------
# Feature Importance (Random Forest)
# -----------------------------------
rf = RandomForestClassifier()
rf.fit(X, y)

importances = rf.feature_importances_
top_features = X.columns[np.argsort(importances)[-4:]]

# -----------------------------------
# Hybrid Model (RF + MLP)
# -----------------------------------
X_hybrid = df[top_features]
y_hybrid = y

X_train_h, X_test_h, y_train_h, y_test_h = train_test_split(
    X_hybrid, y_hybrid, test_size=0.3, random_state=42)

X_train_h = scaler.fit_transform(X_train_h)
X_test_h = scaler.transform(X_test_h)

hybrid = MLPClassifier(max_iter=500)
hybrid.fit(X_train_h, y_train_h)

hybrid_pred = hybrid.predict(X_test_h)
results["Hybrid Model"] = accuracy_score(y_test_h, hybrid_pred)

# -----------------------------------
# RESULTS
# -----------------------------------
print("\nMODEL COMPARISON RESULTS\n")
for model, acc in results.items():
    print(f"{model}: {acc*100:.2f}%")

print("\nTop Features used in Hybrid Model:")
for f in top_features:
    print("-", f)


output:
import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.neural_network import MLPClassifier

# -----------------------------------
# EMBEDDED DATASET (ONLINE COMPILER)
# -----------------------------------
data = {
    "studytime": [2,3,1,4,2,3,1,4,2,3,4,1,2,3,4],
    "absences": [4,2,10,0,6,3,12,1,5,2,0,14,3,4,1],
    "failures": [0,0,2,0,1,0,3,0,1,0,0,2,1,0,0],
    "internet": [1,1,0,1,0,1,0,1,0,1,1,0,1,1,1],
    "G1": [12,14,8,16,10,15,7,17,11,13,18,6,12,14,16],
    "G2": [13,15,9,17,11,14,8,18,12,14,17,7,13,15,17],
    "G3": ["Medium","High","Low","High","Medium",
           "High","Low","High","Medium","Medium",
           "High","Low","Medium","High","High"]
}

df = pd.DataFrame(data)

# -----------------------------------
# Encode Target
# -----------------------------------
df["G3"] = df["G3"].map({"Low":0, "Medium":1, "High":2})

# -----------------------------------
# Split Data
# -----------------------------------
X = df.drop("G3", axis=1)
y = df["G3"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42)

# -----------------------------------
# Scaling
# -----------------------------------
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# -----------------------------------
# Models
# -----------------------------------
models = {
    "Random Forest": RandomForestClassifier(),
    "Decision Tree": DecisionTreeClassifier(),
    "SVM": SVC(),
    "Naive Bayes": GaussianNB(),
    "MLP": MLPClassifier(max_iter=500)
}

results = {}

for name, model in models.items():
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    results[name] = accuracy_score(y_test, pred)

# -----------------------------------
# Feature Importance (Random Forest)
# -----------------------------------
rf = RandomForestClassifier()
rf.fit(X, y)

importances = rf.feature_importances_
top_features = X.columns[np.argsort(importances)[-4:]]

# -----------------------------------
# Hybrid Model (RF + MLP)
# -----------------------------------
X_hybrid = df[top_features]
y_hybrid = y

X_train_h, X_test_h, y_train_h, y_test_h = train_test_split(
    X_hybrid, y_hybrid, test_size=0.3, random_state=42)

X_train_h = scaler.fit_transform(X_train_h)
X_test_h = scaler.transform(X_test_h)

hybrid = MLPClassifier(max_iter=500)
hybrid.fit(X_train_h, y_train_h)

hybrid_pred = hybrid.predict(X_test_h)
results["Hybrid Model"] = accuracy_score(y_test_h, hybrid_pred)

# -----------------------------------
# RESULTS
# -----------------------------------
print("\nMODEL COMPARISON RESULTS\n")
for model, acc in results.items():
    print(f"{model}: {acc*100:.2f}%")

print("\nTop Features used in Hybrid Model:")
for f in top_features:
    print("-", f)
